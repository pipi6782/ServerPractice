/*
	a = a+1 이라는 연산이 있다고 해보자.
	사람이 볼 때는 이 연산이 바로 1만 더하고 끝나는 연산으로 보일 수 있지만
	컴퓨터 내부적으로는 그렇지 않다.
	컴퓨터의 입장에서 위 연산은 세 단계로 이루어 진다.
	1. CPU의 레지스터에 램에 저장된 변수의 값을 가져온다.
	2. 레지스터에 저장된 값에다가 1을 더한다. (이때 쓰는것이 ALU(산술 논리 장치)이다)
	3. 1이 더해진 값을 다시 램에 저장한다.

	단일 스레드로 작업을 한다면 이 작업이 순차적으로 일어나기 때문에 문제가 없다.
	하지만 멀티 스레드로 병렬 작업을 한다면 공통 변수를 사용할 때 문제가 발생하는데
	1 >> 2 >> 3 >> 1 >> 2 >> 3 의 순서로 일어난다는 보장이 없기 때문이다.
	1 >> 2 >> 1 >> 3 >> 2 >> 3 의 순서로 일어난다면 결과값은 2가 아닌 1이 증가되고 끝나게 된다.
	이런 문제를 보완하기 위해서는 1 >> 2 >> 3 을 하나로 묶어서 연산을 한번 하면 무조건 세단계가 진행되게 하는 것이다.
	이런 기능을 지원하는 것이 atomic 클래스이다.
*/

#include <iostream>
#include <atomic>
#include <thread>

using namespace std;

atomic<int> num = 0;

void Add()
{
	for (int i = 0; i < 10000; i++)
	{
		num++;
	}
}

void Sub()
{
	for (int i = 0; i < 10000; i++)
	{
		num--;
	}
}


int main()
{
	thread t1(Add);
	thread t2(Sub);

	t1.join();
	t2.join();

	/*
		위 코드는 이전 코드와 거의 비슷하지만 정확하게 0이 나오게 된다.
		그 이유는 atomic클래스를 이용하여 연산이 진행되는 세단계를 하나로 묶어서 처리하기 때문이다.
		그러면 "모든 변수들을 atomic클래스를 써서 해버리면 되는거 아니야?" 라고 생각할 수 있지만 그럴 수 없는 이유는
		atomic클래스를 이용하여 연산하는 것이 생각보다 무거울 뿐더러
		int, double처럼 간단한 자료형들만 지원하고 atomic<vector<int>>와 같은 것들은 쓸 수가 없기 때문이다.
	*/
}