/*
옛날의 cpu는 한개의 코어밖에 없었다.
하지만 실행해야 하는 프로그램은 한개 뿐만이 아니었고 이를 처리하기 위한 다양한 방식들이 존재헀다.
하지만 기술이 점점 발전하면서 cpu역시 계속 발전해왔고 코어 수 역시 늘아났다.
멀티 스레드 프로그래밍은 기존의 단일 코어를 사용하던 것에서 벗어나 최대한의 효율을 끌어내기 위한 것!!
*/

/*
C++ 11이 도입 되기 전에는 윈도우에서는
윈도우API인 CreateHandle을 이용해서 스레드를 생성할 수 있었다.
하지만 이는 운영체제에 종속적이라는 문제가 있었고
C++ 11부터는 운영체제에 종속적이지 않으면서 스레드를 생성할 수 있는
thread클래스가 등장하게 됐다.
*/

#include <iostream>
// iostream하니까 생각난건데 멀티스레드로 뭔가를 출력할 때는 cout을 쓰지 않는 것이 좋다.
// << 역시 연산자이기 때문에 출력을 하기 위해 비트 연산을 할 때 다른 스레드도 연산을 할 수 있고 출력되는 값이 섞여서 나올 수도 있다. 123 456 이 1 2456 3 이 되는 느낌
// 이를 방지하고 싶다면 cout대신 printf를 사용하는 것이 좋은데 그 이유는 cout과 달리 printf는 출력하는 값 자체를 상수로 치환해버려서 한번에 출력하기 때문이다.
// 단, printf를 쓰고 싶다면 데이터 포맷에 주의하도록 하자.
#include <thread>

using namespace std;

int num = 0;

void Add()
{
	for (int i = 0; i < 10000; i++)
	{
		num++;
	}
} 

void Sub()
{
	for (int i = 0; i < 10000; i++)
	{
		num--;
	}
}

int main()
{
	thread t1(Add);
	thread t2(Sub);

	/*
		스레드 클래스에서 자주 사용하는 기능들이 몇개 있는데
		대표적으로
		hardware_concurrency : 논리적으로 실행 가능한 스레드의 갯수를 의미함 
		CPU 스펙에서 스레드가 기준!! 6C12T cpu를 사용한다면 12가 나오는 식
		get_id : 스레드는 실행될 때마다 각 스레드마다 고유한 아이디가 부여되는데 그 아이디를 얻어온다.
		detach : 스레드를 thread객체에서 분리하여 독립된 스레드로 바꿈. 리눅스에서는 이를 데몬 프로세스라고 함
		join : 해당 스레드가 끝날 때 까지 계속 기다려준다. 스레드가 무한루프를 돌고 있다면 탈출할 때 까지 기다려준다.
	*/
	t1.join();
	t2.join();

	/*
		위 코드는 두개의 스레드로 각각 1씩 10000번 더하는 함수와 뺴는 함수를 실행시킨 것이다.
		하지만 위 코드의 결과는 10000번씩 1을 더하고 뺐지만 결과는 0이 아니다.
		그 이유는 연산에 있어서 원자성이 확보되지 않았기 때문이다.
	*/
}